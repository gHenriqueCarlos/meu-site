<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mago vs Zombie - Infinito</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0b0e14; font-family: 'Verdana', sans-serif; touch-action: none; }
        canvas { display: block; background: #12141a; }
        #ui { 
            position: absolute; top: 15px; left: 15px; color: #fff; 
            pointer-events: none; text-shadow: 2px 2px 5px #000; font-size: 16px;
            border-left: 4px solid #00f2ff; padding-left: 12px; z-index: 10;
        }
        #joystick-base {
            position: absolute; bottom: 40px; left: 40px;
            width: 80px; height: 80px; background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(0, 242, 255, 0.2); border-radius: 50%;
            display: none; z-index: 50;
        }
        #joystick-stick {
            position: absolute; top: 20px; left: 20px;
            width: 40px; height: 40px; background: #00f2ff;
            border-radius: 50%; opacity: 0.4;
        }
        #upgradeMenu {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(20, 20, 30, 0.98);
            padding: 30px; border: 3px solid #00f2ff; border-radius: 20px;
            text-align: center; color: white; z-index: 100; width: 280px;
        }
        .option { background: #2a2a40; padding: 15px; margin: 10px; cursor: pointer; border-radius: 10px; border: 1px solid #444; }
        .option:hover { background: #00f2ff; color: black; }
    </style>
</head>
<body>
    <div id="ui">
        <b style="color: #00f2ff;">MAGO VS ZOMBIE</b><br>
        LVL: <span id="lvl">1</span> | XP: <span id="coins">0</span><br>
        HP: <span id="hp">100</span>
    </div>

    <div id="joystick-base"><div id="joystick-stick"></div></div>

    <div id="upgradeMenu">
        <h2>PODER ARCANO</h2>
        <div id="optionsContainer"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const joyBase = document.getElementById('joystick-base');
const joyStick = document.getElementById('joystick-stick');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let isPaused = false;
let frameCount = 0;
let hasAura = false;

// O Jogador agora fica fixo no centro visual, mas rastreamos sua "posi√ß√£o no mundo"
let player = {
    worldX: 0, worldY: 0,
    screenX: canvas.width / 2, screenY: canvas.height / 2,
    size: 25, speed: 4.5, hp: 100, level: 1, xp: 0, xpNextLvl: 8,
    projectileSpeed: 8, auraRadius: 85, auraDamage: 2.5, auraAngle: 0
};

let enemies = [];
let projectiles = [];
let enemyProjectiles = [];
let particles = [];
let drops = [];
let obstacles = [];
let keys = {};
let touchData = { active: false, startX: 0, startY: 0, moveX: 0, moveY: 0 };

// Gerar obst√°culos iniciais espalhados pelo "mundo"
function spawnInitialObstacles() {
    for (let i = 0; i < 40; i++) {
        obstacles.push({
            worldX: (Math.random() - 0.5) * 4000,
            worldY: (Math.random() - 0.5) * 4000,
            size: 40, type: Math.random() > 0.5 ? "üå≥" : "ü™®"
        });
    }
}
spawnInitialObstacles();

// Listeners de Controles
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('touchstart', e => {
    joyBase.style.display = 'block'; touchData.active = true;
    touchData.startX = e.touches[0].clientX; touchData.startY = e.touches[0].clientY;
    joyBase.style.left = (touchData.startX - 40) + 'px'; joyBase.style.top = (touchData.startY - 40) + 'px';
});
window.addEventListener('touchmove', e => {
    if (!touchData.active) return;
    let angle = Math.atan2(e.touches[0].clientY - touchData.startY, e.touches[0].clientX - touchData.startX);
    let dist = Math.min(getDist(e.touches[0].clientX, e.touches[0].clientY, touchData.startX, touchData.startY), 40);
    touchData.moveX = Math.cos(angle) * (dist / 40);
    touchData.moveY = Math.sin(angle) * (dist / 40);
    joyStick.style.transform = `translate(${touchData.moveX * 30}px, ${touchData.moveY * 30}px)`;
});
window.addEventListener('touchend', () => { touchData.active = false; touchData.moveX = 0; touchData.moveY = 0; joyBase.style.display = 'none'; });

function getDist(x1, y1, x2, y2) { return Math.sqrt((x1-x2)**2 + (y1-y2)**2); }

class Enemy {
    constructor() {
        // Spawn sempre fora da tela em rela√ß√£o ao jogador
        let angle = Math.random() * Math.PI * 2;
        let dist = canvas.width > canvas.height ? canvas.width : canvas.height;
        this.worldX = player.worldX + Math.cos(angle) * dist;
        this.worldY = player.worldY + Math.sin(angle) * dist;
        
        let typeRand = Math.random();
        if(player.level > 4 && typeRand > 0.9) this.setup('tank');
        else if(player.level > 2 && typeRand > 0.8) this.setup('shooter');
        else if(typeRand > 0.6) this.setup('ghost');
        else this.setup('zombie');
    }
    setup(type) {
        this.type = type;
        this.hp = (type==='tank'?30 : type==='ghost'?2 : 6) + (player.level * 2);
        this.speed = (type==='ghost'?3.8 : type==='tank'?1.0 : 1.8);
        this.icon = (type==='tank'?"üëπ" : type==='ghost'?"üëª" : type==='shooter'?"üíÄ" : "üßü");
        this.size = (type==='tank'?50 : 25);
        this.lastShot = 0;
    }
    update() {
        let dx = player.worldX - this.worldX;
        let dy = player.worldY - this.worldY;
        let dist = getDist(this.worldX, this.worldY, player.worldX, player.worldY);
        
        if (this.type === 'shooter' && dist < 300) {
            if (frameCount - this.lastShot > 100) {
                let angle = Math.atan2(dy, dx);
                enemyProjectiles.push({worldX: this.worldX, worldY: this.worldY, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5});
                this.lastShot = frameCount;
            }
        } else {
            this.worldX += (dx/dist) * this.speed;
            this.worldY += (dy/dist) * this.speed;
        }

        if (dist < player.size) player.hp -= 0.4;
        if (hasAura && dist < player.auraRadius) this.hp -= (player.auraDamage / 10);
    }
}

function update() {
    if (isPaused) return;
    if (player.hp <= 0) { alert("Game Over!"); location.reload(); return; }

    // Movimenta√ß√£o do Mundo (Inverso do Jogador)
    let moveX = 0, moveY = 0;
    if (keys['w']) moveY -= player.speed;
    if (keys['s']) moveY += player.speed;
    if (keys['a']) moveX -= player.speed;
    if (keys['d']) moveX += player.speed;
    if (touchData.active) {
        moveX += touchData.moveX * player.speed;
        moveY += touchData.moveY * player.speed;
    }
    
    player.worldX += moveX;
    player.worldY += moveY;

    // Aumentar inimigos no come√ßo: Spawn mais frequente
    let spawnRate = Math.max(10, 50 - player.level * 4);
    if (frameCount % spawnRate === 0 && enemies.length < 100) enemies.push(new Enemy());

    // Mira e Proj√©teis
    if (frameCount % 25 === 0 && enemies.length > 0) {
        let nearest = null; let minDist = Infinity;
        enemies.forEach(e => {
            let d = getDist(player.worldX, player.worldY, e.worldX, e.worldY);
            if(d < minDist) { minDist = d; nearest = e; }
        });
        if(nearest) {
            let angle = Math.atan2(nearest.worldY - player.worldY, nearest.worldX - player.worldX);
            projectiles.push({worldX: player.worldX, worldY: player.worldY, vx: Math.cos(angle)*player.projectileSpeed, vy: Math.sin(angle)*player.projectileSpeed});
        }
    }

    projectiles.forEach((p, pi) => {
        p.worldX += p.vx; p.worldY += p.vy;
        enemies.forEach((e) => {
            if (getDist(p.worldX, p.worldY, e.worldX, e.worldY) < e.size) { 
                e.hp -= 8; projectiles.splice(pi, 1); 
            }
        });
        if(getDist(p.worldX, p.worldY, player.worldX, player.worldY) > 1000) projectiles.splice(pi, 1);
    });

    enemyProjectiles.forEach((ep, epi) => {
        ep.worldX += ep.vx; ep.worldY += ep.vy;
        if (getDist(ep.worldX, ep.worldY, player.worldX, player.worldY) < player.size) {
            player.hp -= 12; enemyProjectiles.splice(epi, 1);
        }
    });

    drops.forEach((d, di) => {
        if (getDist(player.worldX, player.worldY, d.worldX, d.worldY) < 50) {
            player.xp++; drops.splice(di, 1);
            if (player.xp >= player.xpNextLvl) { 
                player.level++; player.xp = 0; player.xpNextLvl += 6; showUpgradeMenu(); 
            }
        }
    });

    enemies.forEach((e, ei) => {
        e.update();
        if (e.hp <= 0) { drops.push({worldX: e.worldX, worldY: e.worldY}); enemies.splice(ei, 1); }
    });

    frameCount++;
    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.fillStyle = "rgba(18, 20, 26, 0.4)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Grid de fundo para refor√ßar a sensa√ß√£o de movimento
    ctx.strokeStyle = "rgba(0, 242, 255, 0.05)";
    ctx.lineWidth = 1;
    let gridSize = 100;
    let offsetX = -player.worldX % gridSize;
    let offsetY = -player.worldY % gridSize;
    for(let x=offsetX; x<canvas.width; x+=gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
    for(let y=offsetY; y<canvas.height; y+=gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

    // Desenhar objetos em rela√ß√£o √† c√¢mera (jogador no centro)
    function toScreen(wx, wy) {
        return { x: wx - player.worldX + player.screenX, y: wy - player.worldY + player.screenY };
    }

    obstacles.forEach(obs => {
        let pos = toScreen(obs.worldX, obs.worldY);
        ctx.font = obs.size + "px serif";
        ctx.fillText(obs.type, pos.x - 20, pos.y + 15);
    });

    if (hasAura) {
        ctx.strokeStyle = "#00f2ff"; ctx.lineWidth = 2; ctx.shadowBlur = 10; ctx.shadowColor = "#00f2ff";
        ctx.beginPath(); ctx.arc(player.screenX, player.screenY, player.auraRadius, 0, Math.PI*2); ctx.stroke();
        ctx.shadowBlur = 0;
    }

    ctx.font = "35px serif";
    ctx.fillText("üßô‚Äç‚ôÇÔ∏è", player.screenX - 18, player.screenY + 12);
    
    enemies.forEach(e => {
        let pos = toScreen(e.worldX, e.worldY);
        ctx.font = e.size + "px serif";
        ctx.fillText(e.icon, pos.x - (e.size/2), pos.y + (e.size/2));
    });
    
    ctx.fillStyle = "#00f2ff"; 
    projectiles.forEach(p => {
        let pos = toScreen(p.worldX, p.worldY);
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 6, 0, Math.PI*2); ctx.fill();
    });

    ctx.fillStyle = "#ff4444"; 
    enemyProjectiles.forEach(ep => {
        let pos = toScreen(ep.worldX, ep.worldY);
        ctx.beginPath(); ctx.arc(pos.x, pos.y, 5, 0, Math.PI*2); ctx.fill();
    });

    drops.forEach(d => {
        let pos = toScreen(d.worldX, d.worldY);
        ctx.font = "20px serif"; ctx.fillText("üíé", pos.x - 10, pos.y + 10);
    });

    document.getElementById('lvl').innerText = player.level;
    document.getElementById('hp').innerText = Math.max(0, Math.floor(player.hp));
    document.getElementById('coins').innerText = player.xp;
}

function showUpgradeMenu() {
    isPaused = true;
    const container = document.getElementById('optionsContainer');
    container.innerHTML = `
        <div class="option" onclick="applyUpgrade('speed')">‚ö° Velocidade</div>
        <div class="option" onclick="applyUpgrade('aura')">üåÄ Aura M√≠stica</div>
        <div class="option" onclick="applyUpgrade('hp')">‚ù§Ô∏è Curar</div>
    `;
    document.getElementById('upgradeMenu').style.display = 'block';
}

function applyUpgrade(type) {
    if (type === 'speed') player.speed += 0.5;
    if (type === 'hp') player.hp = 100;
    if (type === 'aura') hasAura = true;
    document.getElementById('upgradeMenu').style.display = 'none';
    isPaused = false;
    requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
